# Summary

Technical design for Mission 2: Wire MC Dashboard backend routes and build frontend views for audit trail, findings, and briefings. Covers all 4 implementation tasks with concrete signatures, data flow, and integration points.

---

## Task 1A: Fix Route Mounting in serve.go

### Current State

`serve.go` creates its own `http.NewServeMux()` and registers inline handlers for `/api/health`, `/api/status`, `/api/tokens`, `/api/workers`, and placeholder endpoints. `api.Server.Routes()` is never mounted, so `/api/audit`, `/api/tasks`, `/api/graph`, `/api/gates`, `/api/zones`, `/api/checkpoints` etc. are dead code.

### Design

**Strategy:** Replace inline handlers with `api.NewServer(...)`, use its `Routes()` as the base handler, keep `/ws` and OpenClaw bridge on an outer mux that delegates unmatched to `apiServer.Routes()`.

```go
// In Run(), replace the HTTP routes section with:

// Create API server (replaces all inline /api/* handlers)
apiServer := api.NewServer(missionDir, hub, trk, acc)
apiRoutes := apiServer.Routes()

// Outer mux for WebSocket + OpenClaw (non-api.Server routes)
mux := http.NewServeMux()
mux.HandleFunc("/ws", hub.HandleWebSocket)

// OpenClaw bridge routes (conditionally registered, same as now)
// ... bridge setup unchanged, registers on mux ...

// Delegate all other routes to api.Server
mux.Handle("/api/", apiRoutes)

// Apply middleware (unchanged)
handler := api.Chain(mux, api.CORSMiddleware, api.AuthMiddleware)
```

**What to remove from serve.go:**

- Inline handlers: `/api/health`, `/api/status`, `/api/tokens`, `/api/workers`, `/api/requirements`, `/api/requirements/coverage`, `/api/specs`, `/api/specs/orphans`
- The local `writeJSON` function (duplicates `api.writeJSON`)

**What stays in serve.go:**

- `/ws` handler (WebSocket, not in api.Server)
- OpenClaw bridge route registration (`ocHandler.RegisterRoutes(mux)` etc.)
- `bridgeWatcherToHub`, `handleFindingsReady`, `markTaskComplete`, `buildState`, `readJSONL`, `findMissionDir`
- The fallback `/api/openclaw/status` and `/api/chat` for when bridge is not connected

**OpenClaw override:** When bridge is connected, `ocHandler.RegisterRoutes(mux)` registers `/api/openclaw/status` and `/api/chat` on the outer mux. Since Go 1.22 ServeMux gives precedence to the most specific match, and both muxes register the same paths, the outer mux's explicit routes win over the `mux.Handle("/api/", apiRoutes)` catch-all. This is correct — bridge routes override api.Server's placeholders.

**buildState() — add audit:** Currently returns `workers`, `tokens`, `stage`, `gates`, `tasks`. Add `audit` key so WebSocket `initial_state` sync includes audit entries:

```go
// In buildState(), after tasks block:
if audit, err := readJSONL(filepath.Join(missionPath, "..", "audit.jsonl")); err == nil {
    state["audit"] = audit
}
```

Note: `audit.jsonl` lives at `.mission/audit.jsonl`, not `.mission/state/audit.jsonl`. The `missionPath` variable in `buildState` points to `.mission/state`, so use `filepath.Join(missionDir, ".mission", "audit.jsonl")` directly.

### Acceptance

- All `/api/*` endpoints return 200 (audit, tasks, graph, gates, zones, checkpoints, health, status, tokens, workers)
- `/ws` still works
- OpenClaw bridge routes still override when connected
- `go test ./...` passes

---

## Task 1BC: Findings + Briefings Endpoints

### Design

**Add to `handleTaskRouter` in routes.go:**

```go
func (s *Server) handleTaskRouter(w http.ResponseWriter, r *http.Request) {
    path := strings.TrimPrefix(r.URL.Path, "/api/tasks/")
    parts := strings.Split(path, "/")
    if len(parts) == 0 || parts[0] == "" {
        respondError(w, http.StatusBadRequest, "task ID required")
        return
    }
    id := parts[0]

    if len(parts) > 1 {
        switch parts[1] {
        case "dependencies":
            if r.Method == http.MethodPost {
                s.handleTaskDependencies(w, r, id)
                return
            }
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        case "findings":
            if r.Method == http.MethodGet {
                s.handleTaskFindings(w, r, id)
                return
            }
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        case "briefing":
            if r.Method == http.MethodGet {
                s.handleTaskBriefing(w, r, id)
                return
            }
            http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
            return
        }
    }
    // ... existing GET/PATCH handling unchanged
}
```

**New handlers in handlers.go:**

```go
// validateTaskID rejects IDs with path traversal characters.
func validateTaskID(id string) bool {
    return !strings.ContainsAny(id, "../\\") && id != "" && !strings.Contains(id, "..")
}

// handleTaskFindings serves .mission/findings/{id}.md as text/markdown.
func (s *Server) handleTaskFindings(w http.ResponseWriter, r *http.Request, id string) {
    if !validateTaskID(id) {
        respondError(w, http.StatusBadRequest, "invalid task ID")
        return
    }

    path := s.missionPath("findings", id+".md")
    data, err := os.ReadFile(path)
    if err != nil {
        if os.IsNotExist(err) {
            respondError(w, http.StatusNotFound, "findings not found")
            return
        }
        respondError(w, http.StatusInternalServerError, "failed to read findings")
        return
    }

    w.Header().Set("Content-Type", "text/markdown; charset=utf-8")
    w.WriteHeader(http.StatusOK)
    w.Write(data)
}

// handleTaskBriefing serves .mission/handoffs/{id}-briefing.json as application/json.
func (s *Server) handleTaskBriefing(w http.ResponseWriter, r *http.Request, id string) {
    if !validateTaskID(id) {
        respondError(w, http.StatusBadRequest, "invalid task ID")
        return
    }

    path := s.missionPath("handoffs", id+"-briefing.json")
    data, err := os.ReadFile(path)
    if err != nil {
        if os.IsNotExist(err) {
            respondError(w, http.StatusNotFound, "briefing not found")
            return
        }
        respondError(w, http.StatusInternalServerError, "failed to read briefing")
        return
    }

    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(http.StatusOK)
    w.Write(data)
}
```

**Key details:**

- `s.missionPath()` already exists and builds `{missionDir}/.mission/{parts...}` — no new helpers needed
- `validateTaskID` uses `strings.ContainsAny` for single-char checks plus explicit `..` check
- Returns raw file content, not JSON-wrapped — markdown stays markdown, JSON stays JSON

### Acceptance

- `GET /api/tasks/{id}/findings` → 200 + `text/markdown` body
- `GET /api/tasks/{id}/briefing` → 200 + `application/json` body
- Missing files → 404 JSON error
- Traversal attempts → 400 JSON error

---

## Task 2A: Audit View — Real Data Wiring

### Current State

The data flow is **already wired end-to-end**:

1. `useMCWebSocket` subscribes to `audit` topic
2. On `initial_state` sync, it reads `d.audit` into state
3. On `audit` topic events, it appends to `state.audit`
4. `MCClient` passes `mcState.audit` to `ActivityView`
5. `ActivityView` renders audit entries with category icons, time-ago, filtering

### What's Missing

`buildState()` in `serve.go` doesn't include `audit` — so `initial_state` sync has no audit data. Fix is in Task 1A (add audit to buildState).

### Verification After Task 1A

Once `buildState()` includes `audit`:

1. WebSocket `initial_state` will include `audit: [...]`
2. `useMCWebSocket` line `audit: (Array.isArray(d?.audit) ? d.audit : []) as AuditEntry[]` picks it up
3. Real-time updates via `case "audit":` in the event handler appends new entries
4. No frontend code changes needed

### Only If Needed

If audit data is too large for initial sync, add a direct fetch:

```typescript
// In useMCWebSocket, after initial_state handling:
useEffect(() => {
  if (connected) {
    fetch(`${MC_API_URL}/api/audit?limit=100`)
      .then((r) => r.json())
      .then((data) => {
        if (data.entries) {
          setState((prev) => ({ ...prev, audit: data.entries }));
        }
      });
  }
}, [connected]);
```

**Recommendation:** Start without the extra fetch. The `buildState()` fix in Task 1A should be sufficient. Add the fetch only if audit.jsonl grows large enough to impact WebSocket sync performance.

---

## Task 2B: Findings/Briefings Viewer Component

### Component Interface

```typescript
// components/mc/findings-view.tsx

interface FindingsViewProps {
  taskId: string; // Selected task ID
  baseUrl: string; // MC_API_URL
}
```

### Component Design

```tsx
"use client";

import { useState, useEffect } from "react";
import ReactMarkdown from "react-markdown";
import remarkGfm from "remark-gfm";
import { Card } from "./card";
import { SectionLabel } from "./section-label";

type Tab = "findings" | "briefing";

interface FindingsViewProps {
  taskId: string;
  baseUrl: string;
}

export function FindingsView({ taskId, baseUrl }: FindingsViewProps) {
  const [tab, setTab] = useState<Tab>("findings");
  const [markdown, setMarkdown] = useState<string | null>(null);
  const [briefing, setBriefing] = useState<Record<string, unknown> | null>(
    null,
  );
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    setMarkdown(null);
    setBriefing(null);
    setError(null);
    if (!taskId) return;

    setLoading(true);

    // Fetch both in parallel
    Promise.all([
      fetch(`${baseUrl}/api/tasks/${taskId}/findings`).then((r) =>
        r.ok ? r.text() : null,
      ),
      fetch(`${baseUrl}/api/tasks/${taskId}/briefing`).then((r) =>
        r.ok ? r.json() : null,
      ),
    ])
      .then(([md, brief]) => {
        setMarkdown(md);
        setBriefing(brief);
        // Default to whichever tab has data
        if (!md && brief) setTab("briefing");
        else setTab("findings");
      })
      .catch(() => setError("Failed to load"))
      .finally(() => setLoading(false));
  }, [taskId, baseUrl]);

  // ... render with tab switcher, ReactMarkdown for findings,
  //     JSON.stringify(briefing, null, 2) in <pre> for briefing
}
```

### Integration Point

In `TraceView` (or `mc-client.tsx`), add `FindingsView` below the task list when a task is selected:

```tsx
// In trace-view.tsx or mc-client.tsx
{
  view === "trace" && (
    <>
      <TraceView
        graph={null}
        tasks={mcState.tasks}
        onSelectTask={setSelectedTask}
      />
      {selectedTask && (
        <FindingsView taskId={selectedTask} baseUrl={MC_API_URL} />
      )}
    </>
  );
}
```

`TraceView` currently has no task selection callback. Add:

```typescript
interface TraceViewProps {
  graph: GraphData | null;
  tasks: Task[];
  selectedTaskId?: string; // NEW
  onSelectTask?: (id: string) => void; // NEW
}
```

The `selectedTaskId` state lives in `MCClient` (lifted up), passed down to both `TraceView` and `FindingsView`.

### Dependencies

- `react-markdown` + `remark-gfm` — add to `package.json`
- Styling: use existing dark theme (`bg-[#07070e]`, `text-[#e8e4df]`, accent `#c4b5a0`), existing `Card` component

---

## Data Flow Diagram

```
┌─────────────────────────────────────────────────────────────┐
│ Frontend (Darlington)                                        │
│                                                              │
│  MCClient                                                    │
│  ├─ useMCWebSocket()                                         │
│  │  ├─ WS connect → subscribe [stage,task,worker,...,audit]  │
│  │  ├─ request_sync → receives initial_state                 │
│  │  │   └─ includes audit[] from buildState()  ◄── Task 1A  │
│  │  └─ audit topic events → append to state.audit            │
│  │                                                           │
│  ├─ ActivityView                                             │
│  │  └─ renders mcState.audit (already wired)                 │
│  │                                                           │
│  └─ TraceView + FindingsView                                 │
│     ├─ user clicks task → setSelectedTask(id)                │
│     └─ FindingsView fetches:                                 │
│        ├─ GET /api/tasks/{id}/findings  ◄── Task 1BC        │
│        └─ GET /api/tasks/{id}/briefing  ◄── Task 1BC        │
│                                                              │
├──────────────────────────┬──────────────────────────────────┤
│ Backend (MissionControl) │                                   │
│                          │                                   │
│  serve.go                │  api.Server (routes.go)           │
│  ├─ /ws (WebSocket)      │  ├─ /api/audit (handleAudit)     │
│  ├─ /api/openclaw/*      │  ├─ /api/tasks/{id}/findings     │
│  └─ mux.Handle("/api/",  │  ├─ /api/tasks/{id}/briefing     │
│       apiRoutes) ────────┼──┤  ├─ /api/tasks, /api/graph    │
│                          │  ├─ /api/gates, /api/zones        │
│  buildState()            │  ├─ /api/checkpoints              │
│  └─ reads audit.jsonl    │  └─ /api/health, /api/status     │
│     for WS initial_state │                                   │
└──────────────────────────┴──────────────────────────────────┘
```

---

## File Change Summary

| File                                          | Change                                                                                                                                                   | Task |
| --------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ---- |
| `MissionControl/orchestrator/serve/serve.go`  | Create `api.NewServer`, mount `Routes()` via `mux.Handle("/api/", ...)`, remove 8 inline handlers, add audit to `buildState()`, remove local `writeJSON` | 1A   |
| `MissionControl/orchestrator/api/routes.go`   | Add `findings` and `briefing` cases in `handleTaskRouter`                                                                                                | 1BC  |
| `MissionControl/orchestrator/api/handlers.go` | Add `validateTaskID`, `handleTaskFindings`, `handleTaskBriefing`                                                                                         | 1BC  |
| `Darlington/lib/mc/use-mc-websocket.ts`       | Possibly none (verify after 1A)                                                                                                                          | 2A   |
| `Darlington/components/mc/findings-view.tsx`  | **New file** — tabbed findings/briefing viewer                                                                                                           | 2B   |
| `Darlington/components/mc/trace-view.tsx`     | Add `selectedTaskId` and `onSelectTask` props                                                                                                            | 2B   |
| `Darlington/app/mc/mc-client.tsx`             | Add `selectedTask` state, wire `FindingsView`                                                                                                            | 2B   |
| `Darlington/package.json`                     | Add `react-markdown`, `remark-gfm`                                                                                                                       | 2B   |
