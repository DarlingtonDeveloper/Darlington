# Summary

Security review of the MC Dashboard Visibility components. No critical vulnerabilities found. Several medium/low findings noted below.

## Findings

### ðŸŸ¡ MEDIUM: MC*TOKEN exposed in client bundle via NEXT_PUBLIC* prefix

**File:** `lib/mc/constants.ts`

- `MC_TOKEN` uses `NEXT_PUBLIC_MC_TOKEN`, meaning it's embedded in the client-side JavaScript bundle and visible to any browser user.
- If this token grants write access to MC APIs, any user who opens DevTools can extract it.
- **Recommendation:** If the MC API is internal-only (localhost/VPN), this is acceptable. If exposed to the internet, use a server-side API route as a proxy instead of shipping the token to the client.

### ðŸŸ¡ MEDIUM: WebSocket token passed as query parameter

**File:** `lib/mc/use-mc-websocket.ts` (line in `connect`)

- Token is appended as `?token=...` in the WebSocket URL, which may appear in server access logs, proxy logs, and browser history.
- **Recommendation:** Send auth token in the first WebSocket message after connection, not in the URL.

### ðŸŸ¡ MEDIUM: No authentication on MC API calls (sendChat, approveGate)

**File:** `lib/mc/use-mc-websocket.ts`

- `sendChat` and `approveGate` POST to MC API endpoints without any Authorization header or token.
- `approveGate` is a sensitive action (advancing mission stages) and should require auth.
- **Recommendation:** Add `Authorization: Bearer ${MC_TOKEN}` header to these fetch calls, or use cookie-based auth.

### ðŸŸ¢ LOW: No origin validation on WebSocket reconnection

**File:** `lib/mc/use-mc-websocket.ts`

- The WebSocket auto-reconnects every 3 seconds on close. No backoff or max-retry limit, which could cause a reconnect storm.
- **Recommendation:** Add exponential backoff and a max retry count.

### ðŸŸ¢ LOW: Unvalidated JSON.parse on WebSocket messages

**File:** `lib/mc/use-mc-websocket.ts`

- `JSON.parse(ev.data)` is called without try/catch. A malformed WS message would throw and could break the React state update cycle.
- **Recommendation:** Wrap in try/catch.

### âœ… NO ISSUE: No XSS via dangerouslySetInnerHTML

- Grep across all `components/mc/*.tsx` files found **zero** uses of `dangerouslySetInnerHTML`.
- All data from backend is rendered as React text children (e.g., `{msg.content}`), which React auto-escapes.
- SVG `url(#...)` references in `trace-view.tsx` are hardcoded filter/marker IDs, not user-controlled.

### âœ… NO ISSUE: Data sanitization in adapters

**File:** `lib/mc/adapters.ts`

- Adapters are pure data mapping functions. No HTML generation, no eval, no template literals injected into DOM.
- Type coercions (`as Worker["status"]`) are TypeScript-only and don't affect runtime safety.

### âœ… NO ISSUE: Bridge status polling

**File:** `lib/mc/use-bridge-status.ts`

- Simple `fetch` to `${baseUrl}/api/openclaw/status` checking `res.ok`. No sensitive data exchanged, no credentials sent.
- CORS is handled server-side; the client can't weaken it. Same-origin by default in Next.js.

### ðŸŸ¢ LOW: Chat panel stores gateway token and sessionKey in memory

**File:** `components/mc/chat-panel.tsx`

- `configRef` holds `{ wsUrl, token, sessionKey }` in a React ref. Accessible via DevTools memory inspection.
- The chat panel properly authenticates via challenge/response with device identity signing, which is good.
- Chat messages are rendered as text children (`{msg.content}`), no XSS risk.

### âœ… NO ISSUE: Cost/token data exposure

- Token counts and `cost_usd` are displayed in the dashboard. This is operational data, not secrets.
- No session tokens, API keys, or credentials are rendered in dashboard UI components.

## Overall Assessment

**Risk: LOW** â€” The codebase follows React security best practices (no innerHTML, proper text escaping). The main concerns are around the MC API authentication gap and token-in-URL pattern, both of which are low-risk if the dashboard is internal-only but should be addressed before any public exposure.
