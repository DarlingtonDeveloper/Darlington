# Summary

Technical design for MC Dashboard Mission 3B — Checkpoints, Zones, Projects, Stage Override.

---

## R1: Checkpoint Path Fix + UI

### R1.1 — Fix `handleCheckpoints` in `handlers.go`

**Current:** Reads `.mission/checkpoints/` for subdirectories, returns `{id, timestamp}`.
**Problem:** CLI writes JSON files to `.mission/orchestrator/checkpoints/<timestamp>.json`.

**Change `handleCheckpoints` GET logic:**

```go
func (s *Server) handleCheckpoints(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        s.handleCreateCheckpoint(w, r)
        return
    }

    // Read from orchestrator/checkpoints/ (where CLI writes)
    dir := s.missionPath("orchestrator", "checkpoints")
    entries, err := os.ReadDir(dir)
    if err != nil {
        if os.IsNotExist(err) {
            writeJSON(w, http.StatusOK, []CheckpointInfo{})
            return
        }
        respondError(w, http.StatusInternalServerError, err.Error())
        return
    }

    var checkpoints []CheckpointInfo
    for _, e := range entries {
        if e.IsDir() || !strings.HasSuffix(e.Name(), ".json") {
            continue
        }
        name := strings.TrimSuffix(e.Name(), ".json")
        // Parse JSON file to extract stage, task_count, auto
        var cpData map[string]interface{}
        path := filepath.Join(dir, e.Name())
        if err := readJSON(path, &cpData); err != nil {
            continue
        }
        cp := CheckpointInfo{
            ID:        name,
            Timestamp: name, // timestamp IS the filename
        }
        if stage, ok := cpData["stage"].(string); ok {
            cp.Stage = stage
        }
        if tc, ok := cpData["task_count"].(float64); ok {
            cp.TaskCount = int(tc)
        }
        if auto, ok := cpData["auto"].(bool); ok {
            cp.Auto = auto
        }
        checkpoints = append(checkpoints, cp)
    }
    if checkpoints == nil {
        checkpoints = []CheckpointInfo{}
    }
    writeJSON(w, http.StatusOK, checkpoints)
}
```

### R1.2 — Update `CheckpointInfo` struct in `types.go`

```go
type CheckpointInfo struct {
    ID        string `json:"id"`
    Timestamp string `json:"created_at"`  // renamed to match frontend expectation
    Stage     string `json:"stage"`
    TaskCount int    `json:"task_count,omitempty"`
    Auto      bool   `json:"auto,omitempty"`
}
```

**Frontend `CheckpointInfo` expects:** `{id, stage, created_at, task_count?, auto?}` — the Go struct must serialize `Timestamp` as `created_at`.

### R1.3 — Add checkpoints to `handleStatus`

In `handleStatus`, after zones section, add:

```go
// Read checkpoints (reuse logic from handleCheckpoints GET)
cpDir := s.missionPath("orchestrator", "checkpoints")
cpEntries, cpErr := os.ReadDir(cpDir)
var checkpoints []CheckpointInfo
if cpErr == nil {
    for _, e := range cpEntries {
        if e.IsDir() || !strings.HasSuffix(e.Name(), ".json") {
            continue
        }
        // ... same parsing as handleCheckpoints ...
    }
}
if checkpoints == nil {
    checkpoints = []CheckpointInfo{}
}
result["checkpoints"] = checkpoints
```

**Refactor suggestion:** Extract checkpoint reading into `func (s *Server) loadCheckpoints() []CheckpointInfo` and call from both `handleStatus` and `handleCheckpoints`.

### R1.4 — WebSocket initial sync

The `use-mc-websocket.ts` initial_state handler already reads `d.checkpoints` from sync data. Once `handleStatus` (which feeds the sync) includes checkpoints, this works automatically. **No frontend change needed.**

---

## R2: Zones View

### R2.1 — Remove hardcoded ZONES from `mission-view.tsx`

**Current:** `const ZONES = ["frontend", "backend", "database", "infra", "shared"];`

**Change:** Derive zones from tasks + workers, add `tasks` to `MissionViewProps`.

```tsx
interface MissionViewProps {
  workers: Worker[];
  tasks: Task[]; // NEW
  gates: Record<string, GateCriteria>;
  tokens: TokenSummary;
  currentStage: string;
  onKillWorker: (id: string) => void;
}
```

**Zone derivation inside component:**

```tsx
// Derive zones from tasks and workers
const allZones = new Set<string>();
tasks.forEach((t) => {
  if (t.zone) allZones.add(t.zone);
});
workers.forEach((w) => {
  if (w.zone) allZones.add(w.zone);
});

const groups = Array.from(allZones)
  .sort()
  .map((z) => ({
    zone: z,
    workers: activeWorkers.filter((w) => w.zone === z),
    tasks: tasks.filter((t) => t.zone === z),
  }))
  .filter((g) => g.workers.length > 0 || g.tasks.length > 0);
```

### R2.2 — Extend `ZoneGroup` component

**Current props (inferred):** `{ zone, workers, defaultOpen, onKillWorker }`

**New props:**

```tsx
interface ZoneGroupProps {
  zone: string;
  workers: Worker[];
  tasks: Task[]; // NEW
  defaultOpen: boolean;
  onKillWorker: (id: string) => void;
}
```

**Render additions per zone:**

- Zone header: `ZONE_GLYPHS[zone] ?? "◻"` + zone name + task count badge
- Task status breakdown: count of pending/in_progress/complete/blocked as small badges
- Task list (collapsible) showing task name, status indicator, assigned worker

### R2.3 — Update `mc-client.tsx` to pass tasks

```tsx
<MissionView
  workers={mcState.workers}
  tasks={mcState.tasks} // ADD
  gates={mcState.gates}
  tokens={mcState.tokens}
  currentStage={mcState.stage.current}
  onKillWorker={handleKillWorker}
/>
```

### R2.4 — WebSocket zone topic

The zone topic handler in `use-mc-websocket.ts` currently does nothing (`case "zone": return prev;`). Since zones are derived from tasks, this is acceptable — task updates already trigger re-derives. **No change needed** unless the backend adds explicit zone events.

---

## R3: Project Switcher + Registry Fix

### R3.1 — Fix `handleProjects` GET in `handlers.go`

**Current:** Reads `~/.mission-control/config.json` (doesn't exist).
**Target:** Read `~/.mc/projects.json` (CLI's registry).

```go
func (s *Server) handleProjects(w http.ResponseWriter, r *http.Request) {
    if r.Method == http.MethodPost {
        s.handleProjectSwitch(w, r)
        return
    }

    home, _ := os.UserHomeDir()
    registryPath := filepath.Join(home, ".mc", "projects.json")

    var registry struct {
        Projects map[string]string `json:"projects"`
    }
    if err := readJSON(registryPath, &registry); err != nil {
        writeJSON(w, http.StatusOK, []ProjectInfo{})
        return
    }

    var projects []ProjectInfo
    for name, path := range registry.Projects {
        projects = append(projects, ProjectInfo{
            Name:   name,
            Path:   path,
            Active: path == s.missionDir,
        })
    }
    sort.Slice(projects, func(i, j int) bool {
        return projects[i].Name < projects[j].Name
    })
    writeJSON(w, http.StatusOK, projects)
}
```

### R3.2 — Add `ProjectInfo` to `types.go`

```go
type ProjectInfo struct {
    Name   string `json:"name"`
    Path   string `json:"path"`
    Active bool   `json:"active"`
}
```

### R3.3 — Add `ProjectInfo` to `types.ts`

```ts
export interface ProjectInfo {
  name: string;
  path: string;
  active: boolean;
}
```

### R3.4 — Project switcher in `dashboard-header.tsx`

Add a dropdown in the header's left identity section:

```tsx
// New state + effect in DashboardHeader (or lift to mc-client.tsx)
const [projects, setProjects] = useState<ProjectInfo[]>([]);
const [showProjectMenu, setShowProjectMenu] = useState(false);

useEffect(() => {
  fetch(`${MC_API_URL}/api/projects`)
    .then((r) => r.json())
    .then(setProjects)
    .catch(() => {});
}, []);

const handleSwitch = async (path: string) => {
  await fetch(`${MC_API_URL}/api/projects`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ path }),
  });
  window.location.reload(); // full re-sync
};
```

**UI:** Clicking the project name in the header opens a dropdown showing all registered projects. Active project has a checkmark. Selecting another triggers switch + reload.

**Props change for DashboardHeader:** None needed if projects are fetched internally. Alternatively, add `projects: ProjectInfo[]` to props and fetch in `mc-client.tsx`.

### R3.5 — WebSocket broadcast on project switch

In `handleProjectSwitch`, after updating `s.missionDir`, broadcast:

```go
if s.hub != nil {
    s.hub.BroadcastRaw("sync", "project_switched", map[string]string{
        "path": s.missionDir,
    })
}
```

Frontend `use-mc-websocket.ts` handles this by triggering a full re-sync:

```ts
case "sync":
  if (event.type === "project_switched") {
    // Re-request full sync
    ws.send(JSON.stringify({ type: "request_sync" }));
  }
  // existing initial_state handling...
```

---

## R4: Stage Override Controls

### R4.1 — Wire Override button in `activity-view.tsx`

Add state and handler:

```tsx
const [showOverrideDialog, setShowOverrideDialog] = useState(false);

// In the render, wire the existing Override button:
<button onClick={() => setShowOverrideDialog(true)}>Override</button>;

{
  showOverrideDialog && (
    <StageOverrideDialog
      currentStage={currentStage}
      onConfirm={async (stage, reason) => {
        const res = await fetch(`${MC_API_URL}/api/stages/override`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ stage, reason }),
        });
        const result = await res.json();
        setShowOverrideDialog(false);
        return result;
      }}
      onCancel={() => setShowOverrideDialog(false)}
    />
  );
}
```

### R4.2 — New `stage-override-dialog.tsx` component

```tsx
interface StageOverrideDialogProps {
  currentStage: string;
  onConfirm: (
    stage: string,
    reason?: string,
  ) => Promise<{ success: boolean; output?: string; error?: string }>;
  onCancel: () => void;
}
```

**Component internals:**

- State: `selectedStage` (default: current), `reason` (string), `loading`, `error`
- Dropdown: maps `STAGES` with `STAGE_ICONS[stage]` prefix
- Warning badge if `STAGES.indexOf(selectedStage) < STAGES.indexOf(currentStage)` (backward) or if skipping stages forward (gate-skipping)
- Confirm button calls `onConfirm(selectedStage, reason)`, shows error on failure
- Cancel button calls `onCancel`

### R4.3 — Add `--reason` support to `handleStageOverride` in `handlers.go`

```go
type StageOverrideRequest struct {
    Stage  string `json:"stage"`
    Reason string `json:"reason,omitempty"` // ADD
}

func (s *Server) handleStageOverride(w http.ResponseWriter, r *http.Request) {
    var req StageOverrideRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        respondError(w, http.StatusBadRequest, "invalid request body")
        return
    }
    if req.Stage == "" {
        respondError(w, http.StatusBadRequest, "stage is required")
        return
    }

    args := []string{"stage", "set", req.Stage}
    if req.Reason != "" {
        args = append(args, "--reason", req.Reason)
    }

    out, err := s.runMC(args...)
    if err != nil {
        respondError(w, http.StatusInternalServerError, fmt.Sprintf("mc stage set failed: %s", out))
        return
    }
    // Broadcast stage change via WebSocket
    if s.hub != nil {
        s.hub.BroadcastRaw("stage", "override", map[string]string{
            "current": req.Stage,
            "reason":  req.Reason,
        })
    }
    writeJSON(w, http.StatusOK, CommandResult{Success: true, Output: out})
}
```

---

## Data Flow Summary

```
┌─────────────────┐     GET /api/status         ┌──────────────┐
│  mc-client.tsx   │◄────(includes checkpoints)──│  handlers.go │
│                  │     GET /api/projects        │              │
│  useMCWebSocket  │◄────(~/.mc/projects.json)───│              │
│                  │     POST /api/stages/override│              │
│  ActivityView    │────(+reason)────────────────►│              │
│                  │     POST /api/projects       │              │
│  DashboardHeader │────(switch path)────────────►│              │
└─────────────────┘     WS broadcast             └──────────────┘
        ▲                    │
        └────────────────────┘
         sync/stage/checkpoint events
```

## Files Changed Summary

| File                                                 | Changes                                                                                                                                                                                                                                                                                        |
| ---------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `MissionControl/orchestrator/api/handlers.go`        | Fix checkpoint path to `orchestrator/checkpoints/`, parse JSON files, add `loadCheckpoints()` helper, add checkpoints to `handleStatus`, fix `handleProjects` to read `~/.mc/projects.json`, add `--reason` + WS broadcast to `handleStageOverride`, add WS broadcast to `handleProjectSwitch` |
| `MissionControl/orchestrator/api/types.go`           | Update `CheckpointInfo` struct (add Stage, TaskCount, Auto; rename Timestamp→CreatedAt json tag), add `ProjectInfo` struct, add `Reason` to `StageOverrideRequest`                                                                                                                             |
| `Darlington/components/mc/mission-view.tsx`          | Remove hardcoded `ZONES`, add `tasks` prop, derive zones from tasks+workers, pass tasks to `ZoneGroup`                                                                                                                                                                                         |
| `Darlington/components/mc/zone-group.tsx`            | Add `tasks` prop, render task count/status breakdown per zone, use `ZONE_GLYPHS`                                                                                                                                                                                                               |
| `Darlington/components/mc/dashboard-header.tsx`      | Add project switcher dropdown (fetch projects, switch on select)                                                                                                                                                                                                                               |
| `Darlington/components/mc/activity-view.tsx`         | Wire Override button to open `StageOverrideDialog`                                                                                                                                                                                                                                             |
| `Darlington/components/mc/stage-override-dialog.tsx` | **NEW** — stage selector with icons, reason field, forward/backward warnings, confirm/cancel                                                                                                                                                                                                   |
| `Darlington/lib/mc/types.ts`                         | Add `ProjectInfo` interface                                                                                                                                                                                                                                                                    |
| `Darlington/lib/mc/use-mc-websocket.ts`              | Handle `project_switched` sync event (re-request sync)                                                                                                                                                                                                                                         |
| `Darlington/app/mc/mc-client.tsx`                    | Pass `tasks` to `MissionView`                                                                                                                                                                                                                                                                  |
