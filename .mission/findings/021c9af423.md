# Summary

Code review of Mission 2 implementation across MissionControl (Go backend) and Darlington (React frontend). Overall: **solid implementation** that closely follows the design doc. A few issues noted below, ranging from minor to medium severity.

## Backend: MissionControl

### orchestrator/serve/serve.go ✅ Good

- Clean refactor: inline handlers removed, `api.NewServer` properly created and mounted
- `/ws` stays on outer mux, OpenClaw bridge routes override correctly via Go 1.22 specificity rules
- `buildState()` correctly reads `audit.jsonl` from `.mission/audit.jsonl` (not `.mission/state/`)
- Graceful shutdown, signal handling, atomic writes in `markTaskComplete` all look correct

**Issues:**

1. **[Low] Duplicate `readJSONL` implementations** — `serve.go` has `readJSONL` returning `[]interface{}` (using `json.NewDecoder`) while `api/handlers.go` has `readJSONL` returning `[]map[string]interface{}` (using `bufio.Scanner`). Both work but the inconsistency is confusing. The `api` version is more robust (explicit buffer sizing, handles whitespace). Consider removing the `serve.go` version and using the `api` one, or at minimum documenting why they differ.

2. **[Low] `buildState` audit has no size limit** — if `audit.jsonl` grows large, the entire file is sent via WebSocket `initial_state`. The design doc notes this risk. Not a blocker now but worth a `// TODO: paginate or cap audit in initial sync` comment.

### orchestrator/api/handlers.go ✅ Good

- `validateTaskID` correctly rejects `..`, `/`, `\`, and empty strings
- `handleTaskFindings` and `handleTaskBriefing` follow the same clean pattern: validate → read → serve with correct content-type
- Error handling uses `os.IsNotExist` for 404 vs generic 500 — correct
- `handleAudit` has proper pagination with `offset`/`limit` and filtering by `category`/`actor`

**Issues:**

3. **[Medium] `handleTaskBriefing` serves raw bytes without JSON validation** — The design doc says "Validate JSON before serving (or serve raw with correct content-type)". Currently serves raw bytes with `application/json` content-type. If the file contains invalid JSON, clients get a malformed response with a valid content-type header. Recommend either: (a) `json.Valid(data)` check before serving, or (b) accept the risk and add a comment explaining the choice.

4. **[Low] `handleTaskFindings`/`handleTaskBriefing` ignore `r` parameter** — The `*http.Request` parameter is unused in both handlers. Not a bug (Go doesn't warn on unused method params), but could be simplified to just `(w, id)` if the signature allowed it. Fine as-is for consistency with other handlers.

5. **[Low] `handleProjectSwitch` mutates `s.missionDir` without synchronization** — concurrent requests could race. Low risk in practice (single-user tool) but worth noting.

### orchestrator/api/routes.go ✅ Good

- `handleTaskRouter` cleanly dispatches `findings` and `briefing` sub-paths with correct method enforcement
- Interface-based dependency injection (`HubBroadcaster`, `TrackerReader`, `TokenReader`) is clean
- Method helpers (`methodGET`, `methodPOST`) reduce boilerplate

**Issues:**

6. **[Low] `handleProjectsRouter` has redundant POST handling** — Both the `r.URL.Path == "/api/projects/switch"` check and the fallthrough call `handleProjectSwitch`. The conditional is dead code since both branches do the same thing.

7. **[Low] Unrecognized sub-paths under `/api/tasks/{id}/` fall through to `handleTaskByID`** — e.g. `GET /api/tasks/abc/nonexistent` would try to look up task `abc` and return it (ignoring the extra path segment). Should return 404 for unknown sub-resources. Minor since no security impact.

## Frontend: Darlington

### components/mc/findings-view.tsx ✅ Good

- Parallel fetch of findings + briefing is efficient
- Smart tab auto-selection (defaults to whichever has data)
- Comprehensive ReactMarkdown component overrides matching the dark theme
- Loading/error/empty states all handled
- `taskId: string | null` properly guarded with early `if (!taskId) return null`

**Issues:**

8. **[Medium] Briefing fetch `.json()` can throw on non-JSON 404** — The `.then(r => r.ok ? r.json() : null)` is fine when the server returns JSON errors for 404 (which it does). But if the server is unreachable or returns HTML (e.g. proxy error), `.json()` would throw inside the `.then`, and since it's in `Promise.all`, the `.catch` would fire and set a generic error. This is acceptable but means a briefing-only failure could mask a successful findings fetch. Consider fetching independently.

9. **[Low] No abort controller on unmount** — If `taskId` changes rapidly (user clicking through tasks), stale fetches could resolve and set state for the wrong task. The `useEffect` resets state at the top which mitigates visible bugs, but stale responses could still overwrite newer ones. Add `AbortController` for correctness.

10. **[Low] `code` component block detection** — `className?.includes("language-")` works for fenced code blocks with a language, but fenced blocks without a language specifier won't get block styling. Consider checking the parent element or using `node` prop from react-markdown.

### app/mc/mc-client.tsx ✅ Good

- Clean view switching with proper state management
- `selectedTaskId` state correctly lifted to `MCClient` and passed to both `TraceView` and `FindingsView`
- `FindingsView` only renders in trace view — correct placement
- All action handlers (`handleKillWorker`, `handleApproveGate`, etc.) are concise

**Issues:**

11. **[Medium] No error handling on action fetches** — `handleKillWorker`, `handleApproveGate`, `handleRejectGate`, `handleCreateCheckpoint`, `handleRestoreCheckpoint` all fire-and-forget with no error handling. If any fails, the user gets no feedback. Recommend at minimum a try/catch with a toast or console.error.

12. **[Low] `selectedTaskId` not reset on view change** — If user selects a task in trace view, switches to mission view, then back to trace, the old selection persists and `FindingsView` re-fetches. Not a bug per se but may surprise users. Consider resetting on view change or leaving as-is (could be considered a feature).

### components/mc/trace-view.tsx ✅ Good

- Controlled + uncontrolled pattern via `selectedTaskId`/`localSelectedNodeId` is well done — component works standalone or with lifted state
- SVG graph rendering with proper layout algorithm (stage columns)
- Edge rendering with blocked/normal distinction, arrows, dashed lines
- Filter bar for stage + status

**Issues:**

13. **[Low] SVG text truncation is crude** — `n.title.slice(0, 20) + "…"` doesn't account for character width. Could overflow the node rect with wide characters. A `<clipPath>` or `<foreignObject>` would be more robust, but fine for an internal tool.

14. **[Low] `graph?.ready_count` fallback derivation** — The fallback counts nodes that are not blocked/complete/in_progress (i.e. pending), which matches "ready". But tasks with unmet dependencies that are "pending" aren't truly "ready". This is a pre-existing issue, not introduced by this PR.

## Verdict

**Approve with minor suggestions.** The implementation faithfully follows the requirements and design docs. No blocking issues. The medium-severity items (3, 8, 11) are worth addressing before shipping but aren't showstoppers.

### Priority fixes recommended:

1. Add `json.Valid()` check in `handleTaskBriefing` (issue 3)
2. Add error handling to action fetches in `mc-client.tsx` (issue 11)
3. Consider `AbortController` in `FindingsView` useEffect (issue 9)
