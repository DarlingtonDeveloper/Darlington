# Summary

Research findings for MC Dashboard Mission 3B — Checkpoints, Zones, Projects, Stage Override.

## Q1: What do the endpoints return?

### GET /api/checkpoints

Returns `[]CheckpointInfo` — lists subdirectories of `.mission/checkpoints/`, each as `{id, timestamp}`. POST creates a checkpoint via `mc checkpoint`.

### GET /api/zones

Returns zones from `.mission/state/zones.json` if it exists. Falls back to deriving unique zone names from tasks in `tasks.jsonl`. Returns a sorted `[]string`.

### GET /api/projects

Returns the contents of `~/.mission-control/config.json` (GlobalConfig with projects list, lastProject, preferences). POST switches the active project directory.

### POST /api/stages/override

Accepts `{stage: string}`, calls `mc stage set <stage>`. Returns `{success, output}`. This is a real stage-set operation with gate enforcement.

## Q2: Are these stubs or real implementations?

| Endpoint                           | Status                                                                             |
| ---------------------------------- | ---------------------------------------------------------------------------------- |
| GET /api/checkpoints               | **Real** — reads `.mission/checkpoints/` directory, returns actual checkpoint dirs |
| POST /api/checkpoints              | **Real** — shells out to `mc checkpoint`                                           |
| POST /api/checkpoints/{id}/restart | **Real** — shells out to `mc checkpoint restart {id}`                              |
| GET /api/zones                     | **Real** — reads zones.json or derives from tasks                                  |
| GET /api/projects                  | **Real** — reads `~/.mission-control/config.json`                                  |
| POST /api/projects (switch)        | **Real** — validates .mission dir exists, updates server's missionDir              |
| POST /api/stages/override          | **Real** — shells out to `mc stage set` with full gate enforcement                 |

**Note:** The `projects.go` file has a second, more complete `ProjectsHandler` with CRUD, browse, persona management, and project creation (shells out to `mc init`). This registers its own routes and may coexist with the simpler handler in `handlers.go`.

## Q3: Data shapes returned

- **CheckpointInfo**: `{id: string, timestamp: string}` — id is dir name (e.g. "cp-20260210-231500"), timestamp strips "cp-" prefix
- **Zones**: `string[]` — sorted unique zone names
- **Projects (handlers.go)**: raw `~/.mission-control/config.json` contents — `{projects: [{path, name, lastOpened, mode, ollamaModel}], lastProject, preferences: {theme}}`
- **Projects (projects.go)**: Same GlobalConfig shape, plus `/api/projects/check?path=`, `/api/browse?path=`, persona sub-routes
- **Stage override**: `{success: bool, output: string}`

## Q4: Does the frontend reference these?

**Yes, all four are referenced:**

- **Checkpoints**: `mc-client.tsx` calls POST `/api/checkpoints` and POST `/api/checkpoints/{id}/restart`. Passes `checkpoints` prop to components. WebSocket (`use-mc-websocket.ts`) subscribes to "checkpoint" topic and appends new checkpoints to state. `types.ts` defines `CheckpointInfo {id, timestamp}`.
- **Zones**: `mission-view.tsx` imports `ZoneGroup` component, groups workers by zone. `types.ts` references zone on Task, GraphNode, and Worker types. WebSocket subscribes to "zone" topic.
- **Projects**: Not directly referenced in the listed frontend files (mc-client.tsx, mission-view.tsx). Project management likely lives in a separate page/component.
- **Stage override**: Not directly referenced in the listed files. The stage display exists but override UI may not be built yet.

## Q5: What mc CLI commands exist?

### `mc checkpoint` (checkpoint.go)

- `mc checkpoint` — Create checkpoint (writes to `.mission/orchestrator/checkpoints/<timestamp>.json`)
- `mc checkpoint status` — Session health (duration, task counts, health color)
- `mc checkpoint history` — List sessions from `sessions.jsonl`
- `mc checkpoint query <id>` — View a specific checkpoint's JSON
- `mc checkpoint restart [--from <id>]` — End session, create checkpoint, compile briefing, start new session
- `mc checkpoint auto [--tokens N --reason R]` — Token-aware auto-checkpoint for pre-compaction

### `mc stage` (stage.go)

- `mc stage` — Show current stage
- `mc stage next` — Advance to next stage (with gate enforcement via mc-core)
- `mc stage <name>` — Set specific stage (with gate checks for forward jumps)
- Flags: `--force`, `--reason` for bypassing gates

### `mc project` (project.go)

- `mc project list` — List registered projects from `~/.mc/projects.json`
- `mc project register <name> [path]` — Register a project
- `mc project remove <name>` — Remove from registry
- `mc project link <target> [location]` — Create .mission symlink
- `mc --project <name>` — Global flag to use a registered project

**No `mc zone` command exists.** Zones are derived from task metadata, not managed independently.

## Q6: What .mission/ directory structure exists for each?

### Checkpoints

Two locations exist:

1. **`.mission/checkpoints/`** — Used by the API server's `handleCheckpoints` (reads subdirectories). Currently **empty** in Darlington.
2. **`.mission/orchestrator/checkpoints/`** — Used by `mc checkpoint` CLI (writes `<timestamp>.json` files). Currently **empty** in Darlington.

**Mismatch:** The API reads from `.mission/checkpoints/` but the CLI writes to `.mission/orchestrator/checkpoints/`. These are different paths — the dashboard won't see CLI-created checkpoints.

### Zones

- No `.mission/state/zones.json` exists in Darlington
- Zones are derived dynamically from task `zone` fields in `tasks.jsonl`

### Projects

- **Global config:** `~/.mission-control/config.json` (used by API server's `handleProjects`)
- **Global registry:** `~/.mc/projects.json` (used by CLI's `mc project` commands)
- **Note:** Two separate config files for two separate project concepts — the API uses one, CLI uses another.

### Stage

- `.mission/state/stage.json` — `{current: string, updated_at: string}`
- No separate override file; `mc stage set` directly modifies `stage.json`

## Key Issues Found

1. **Checkpoint path mismatch**: API serves `.mission/checkpoints/` but CLI writes to `.mission/orchestrator/checkpoints/`. Dashboard will always show empty checkpoints list even when checkpoints exist.
2. **Two project registries**: CLI uses `~/.mc/projects.json`, API uses `~/.mission-control/config.json`. These are independent systems.
3. **No zone management CLI**: Zones are implicit (derived from tasks). No CRUD operations exist.
